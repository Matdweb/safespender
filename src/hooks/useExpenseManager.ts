import { useToast } from '@/hooks/use-toast';
import { useCreateExpense, useCreateTransaction } from '@/hooks/useFinancialData';

interface NewExpense {
  title: string;
  category: string;
  amount: number;
  type: 'one-time' | 'monthly';
  date?: string; // YYYY-MM-DD for one-time
  day_of_month?: number; // 1-31 for monthly
}

export const useExpenseManager = () => {
  const { toast } = useToast();
  const createExpenseMutation = useCreateExpense();
  const createTransactionMutation = useCreateTransaction();

  const addExpense = async (expense: NewExpense) => {
    try {
      if (expense.type === 'one-time') {
        // For one-time expenses, create only a transaction record
        await createTransactionMutation.mutateAsync({
          type: 'expense',
          amount: expense.amount,
          description: expense.title,
          date: expense.date!,
          category: expense.category,
          is_reserved: false
        });
      } else {
        // For recurring expenses, create only an expense record
        // Transactions will be generated by the calendar system
        const expenseData = {
          description: expense.title,
          category: expense.category,
          amount: expense.amount,
          is_recurring: true,
          is_reserved: true,
          day_of_month: expense.day_of_month,
          recurring_type: 'monthly',
          recurring_interval: 1,
          next_occurrence_date: calculateNextOccurrence(expense.day_of_month!),
          end_date: null
        };

        await createExpenseMutation.mutateAsync(expenseData);
      }
      
      toast({
        title: "Expense Added!",
        description: `${expense.title} (${expense.category}) - $${expense.amount.toLocaleString()}`,
      });
    } catch (error) {
      console.error('Error adding expense:', error);
      toast({
        title: "Error",
        description: "Failed to add expense. Please try again.",
        variant: "destructive"
      });
    }
  };

  // Helper function to calculate next occurrence for monthly expenses
  const calculateNextOccurrence = (dayOfMonth: number): string => {
    const today = new Date();
    const currentMonth = today.getMonth();
    const currentYear = today.getFullYear();
    
    // Try current month first
    let nextDate = new Date(currentYear, currentMonth, dayOfMonth);
    
    // If the date has already passed this month, move to next month
    if (nextDate <= today) {
      nextDate = new Date(currentYear, currentMonth + 1, dayOfMonth);
    }
    
    // Handle day fallback for months with fewer days
    if (nextDate.getDate() !== dayOfMonth) {
      // The day doesn't exist in this month (e.g., Feb 30), use last day of month
      nextDate = new Date(nextDate.getFullYear(), nextDate.getMonth() + 1, 0);
      // But cap at 28 for February consistency
      if (nextDate.getMonth() === 1 && dayOfMonth > 28) { // February
        nextDate = new Date(nextDate.getFullYear(), 1, 28);
      }
    }
    
    return nextDate.toISOString().split('T')[0];
  };

  return {
    addExpense,
    isLoading: createExpenseMutation.isPending || createTransactionMutation.isPending,
  };
};